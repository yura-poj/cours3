continue
question
continue
self
question
continue
Devise.warden
continue
Devise.warden
current_user
Devise.warden
Devise.warden.first.nil?
continue
Devise.warden.first.nil?
Devise.warden.nil?
Devise.warden
Devise::Warden.nil?
nil.nil?
Devise::Warden.nil?
Devise::Warden&.present?
Devise::Warden&
Devise::Warden.present?
Devise::Warden
current_user
question
question.author?(current_user)
continue
link_to 'Delete question', question, data: {turbo_method: :delete, turbo_confirm: t('confirm.delete.question')}
question
question.author?(current_user)
continue
link_to 'Delete question', question, data: {turbo_method: :delete, turbo_confirm: t('confirm.delete.question')}
question.author?(current_user)
current_user
question.author?
question
q
answers.first
question.best_answer
question.best_answetr
question
questiob
continue
answer
continue
@resource
self
answer
@record
continue
@record
continue
@record
continue
self
@answer
asnwer
continue
render 'shared/errors', resource: answer
= render 'shared/errors', resource: answer
continue
self
@answer
continue
@answer
self
continue
render 'shared/errors', resource: @answer
@answer
continue
 redirect_to(assigns(:exposed_question))
response == redirect_to(assigns(:exposed_question))
response == redirect_to assigns(:exposed_question)
response
continue
attributes_for(:answer)
attributes_for(:question)
return 1
return 
rerutn 
expect { post :create, params: { question: attributes_for(:question), author_id: user } }.to change(Question, :count).by(1)
post :create, params: { question: attributes_for(:question), author_id: user }
Question.count
create(:question)
Question.count
post :create, params: { question: attributes_for(:question), author_id: user }
Question.count
Question.all
post :create, params: { question: attributes_for(:question), author_id: user }
